#summary HoudahEOAccess: framework overview.

= HoudahEOAccess =

The rule engine basically is a re-implementation of the rule engine Apple uses 
for DirectToWeb. As such it retains compatibility with the rule files created 
using Apple’s RuleEditor. 

A major difference between the two implementations is that Apple’s rule 
engine is nested deep within the presentation layer. It has dependences on 
both the WebObjects AppServer and DirectToWeb frameworks. The 
implementation at hand only depends on HoudahFoundation and 
HoudahEOControl. This provides the HoudahRuleEngine with tremendous 
versatility. It is used at the EOControl level to implement rule based 
validation, at presentation level to dynamically generate the UI, across levels 
to provide rich localizable error messages, ... . 

At the heart of the rule engine is the RuleModel. A model is made up of a set 
of rules loaded from a set of **.d2wmodel files. The RuleModelUtilities class 
is able to load models by name or extensions from all frameworks and 
application bundles in the classpath. E.g. all files named **.valid.d2wmodel 
combined make up the rule model used for validation. 

A Rule is made of a left hand side (LHS), a right hand side (RSH) key, a RSH 
assignment and a priority value. The LHS is a qualifier that will be evaluated 
against a given context. The RHS key is the “name” of a value that may be 
computed. The RHS assignment is either a value or a key to evaluate in order 
to get to the desired value. Typically a rule is written as: “LHS => key = value 
[[priority]]”. 

Runtime interaction with the rule engine happens by applying key-value 
coding to a RuleContext instance. A RuleContext represents current 
knowledge. E.g.{ entity=”User”, task=”edit”, key=”name” }. The context must 
be “fed” by the caller prior to being queried. A context may then be queried 
for both known and derived facts. The context above is able to provide a 
value for the key “task” by merely querying its knowledge base. Using the 
rule model, it may also be able to answer other requests. When asked to 
provide a value for the key “formatter”, it will look at all the rules with RHS 
key “formatter”. It will sort those rules by descending priority. Then it will 
evaluate LHS qualifiers against the current context until it finds a match. The 
matching rule’s RHS assignment determines the resulting value. There are 2 
ways rule evaluation may become recursive. We have already seen that 
assignments may call for the evaluation of other keys. Similarly the evaluation 
of the LHS may call back into the rule engine to determine values for keys 
referred to by the qualifier. Beware of infinite recursion!